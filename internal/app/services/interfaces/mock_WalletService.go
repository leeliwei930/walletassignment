// Code generated by mockery v2.43.0. DO NOT EDIT.

package interfaces

import (
	context "context"

	models "github.com/leeliwei930/walletassignment/internal/app/models"
	mock "github.com/stretchr/testify/mock"
)

// MockWalletService is an autogenerated mock type for the WalletService type
type MockWalletService struct {
	mock.Mock
}

type MockWalletService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWalletService) EXPECT() *MockWalletService_Expecter {
	return &MockWalletService_Expecter{mock: &_m.Mock}
}

// Deposit provides a mock function with given fields: ctx, params
func (_m *MockWalletService) Deposit(ctx context.Context, params models.WalletDepositParams) (*models.WalletDeposit, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for Deposit")
	}

	var r0 *models.WalletDeposit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletDepositParams) (*models.WalletDeposit, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletDepositParams) *models.WalletDeposit); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.WalletDeposit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.WalletDepositParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletService_Deposit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Deposit'
type MockWalletService_Deposit_Call struct {
	*mock.Call
}

// Deposit is a helper method to define mock.On call
//   - ctx context.Context
//   - params models.WalletDepositParams
func (_e *MockWalletService_Expecter) Deposit(ctx interface{}, params interface{}) *MockWalletService_Deposit_Call {
	return &MockWalletService_Deposit_Call{Call: _e.mock.On("Deposit", ctx, params)}
}

func (_c *MockWalletService_Deposit_Call) Run(run func(ctx context.Context, params models.WalletDepositParams)) *MockWalletService_Deposit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(models.WalletDepositParams))
	})
	return _c
}

func (_c *MockWalletService_Deposit_Call) Return(_a0 *models.WalletDeposit, _a1 error) *MockWalletService_Deposit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletService_Deposit_Call) RunAndReturn(run func(context.Context, models.WalletDepositParams) (*models.WalletDeposit, error)) *MockWalletService_Deposit_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: ctx, params
func (_m *MockWalletService) Status(ctx context.Context, params models.WalletStatusParams) (*models.WalletStatus, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 *models.WalletStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletStatusParams) (*models.WalletStatus, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletStatusParams) *models.WalletStatus); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.WalletStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.WalletStatusParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletService_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockWalletService_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - ctx context.Context
//   - params models.WalletStatusParams
func (_e *MockWalletService_Expecter) Status(ctx interface{}, params interface{}) *MockWalletService_Status_Call {
	return &MockWalletService_Status_Call{Call: _e.mock.On("Status", ctx, params)}
}

func (_c *MockWalletService_Status_Call) Run(run func(ctx context.Context, params models.WalletStatusParams)) *MockWalletService_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(models.WalletStatusParams))
	})
	return _c
}

func (_c *MockWalletService_Status_Call) Return(_a0 *models.WalletStatus, _a1 error) *MockWalletService_Status_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletService_Status_Call) RunAndReturn(run func(context.Context, models.WalletStatusParams) (*models.WalletStatus, error)) *MockWalletService_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Transactions provides a mock function with given fields: ctx, params
func (_m *MockWalletService) Transactions(ctx context.Context, params models.WalletTransactionsParams) (*models.WalletTransactions, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for Transactions")
	}

	var r0 *models.WalletTransactions
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletTransactionsParams) (*models.WalletTransactions, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletTransactionsParams) *models.WalletTransactions); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.WalletTransactions)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.WalletTransactionsParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletService_Transactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transactions'
type MockWalletService_Transactions_Call struct {
	*mock.Call
}

// Transactions is a helper method to define mock.On call
//   - ctx context.Context
//   - params models.WalletTransactionsParams
func (_e *MockWalletService_Expecter) Transactions(ctx interface{}, params interface{}) *MockWalletService_Transactions_Call {
	return &MockWalletService_Transactions_Call{Call: _e.mock.On("Transactions", ctx, params)}
}

func (_c *MockWalletService_Transactions_Call) Run(run func(ctx context.Context, params models.WalletTransactionsParams)) *MockWalletService_Transactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(models.WalletTransactionsParams))
	})
	return _c
}

func (_c *MockWalletService_Transactions_Call) Return(_a0 *models.WalletTransactions, _a1 error) *MockWalletService_Transactions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletService_Transactions_Call) RunAndReturn(run func(context.Context, models.WalletTransactionsParams) (*models.WalletTransactions, error)) *MockWalletService_Transactions_Call {
	_c.Call.Return(run)
	return _c
}

// Transfer provides a mock function with given fields: ctx, params
func (_m *MockWalletService) Transfer(ctx context.Context, params models.WalletTransferParams) (*models.WalletTransfer, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for Transfer")
	}

	var r0 *models.WalletTransfer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletTransferParams) (*models.WalletTransfer, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletTransferParams) *models.WalletTransfer); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.WalletTransfer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.WalletTransferParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletService_Transfer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transfer'
type MockWalletService_Transfer_Call struct {
	*mock.Call
}

// Transfer is a helper method to define mock.On call
//   - ctx context.Context
//   - params models.WalletTransferParams
func (_e *MockWalletService_Expecter) Transfer(ctx interface{}, params interface{}) *MockWalletService_Transfer_Call {
	return &MockWalletService_Transfer_Call{Call: _e.mock.On("Transfer", ctx, params)}
}

func (_c *MockWalletService_Transfer_Call) Run(run func(ctx context.Context, params models.WalletTransferParams)) *MockWalletService_Transfer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(models.WalletTransferParams))
	})
	return _c
}

func (_c *MockWalletService_Transfer_Call) Return(_a0 *models.WalletTransfer, _a1 error) *MockWalletService_Transfer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletService_Transfer_Call) RunAndReturn(run func(context.Context, models.WalletTransferParams) (*models.WalletTransfer, error)) *MockWalletService_Transfer_Call {
	_c.Call.Return(run)
	return _c
}

// Withdraw provides a mock function with given fields: ctx, params
func (_m *MockWalletService) Withdraw(ctx context.Context, params models.WalletWithdrawalParams) (*models.WalletWithdrawal, error) {
	ret := _m.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for Withdraw")
	}

	var r0 *models.WalletWithdrawal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletWithdrawalParams) (*models.WalletWithdrawal, error)); ok {
		return rf(ctx, params)
	}
	if rf, ok := ret.Get(0).(func(context.Context, models.WalletWithdrawalParams) *models.WalletWithdrawal); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.WalletWithdrawal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, models.WalletWithdrawalParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockWalletService_Withdraw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Withdraw'
type MockWalletService_Withdraw_Call struct {
	*mock.Call
}

// Withdraw is a helper method to define mock.On call
//   - ctx context.Context
//   - params models.WalletWithdrawalParams
func (_e *MockWalletService_Expecter) Withdraw(ctx interface{}, params interface{}) *MockWalletService_Withdraw_Call {
	return &MockWalletService_Withdraw_Call{Call: _e.mock.On("Withdraw", ctx, params)}
}

func (_c *MockWalletService_Withdraw_Call) Run(run func(ctx context.Context, params models.WalletWithdrawalParams)) *MockWalletService_Withdraw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(models.WalletWithdrawalParams))
	})
	return _c
}

func (_c *MockWalletService_Withdraw_Call) Return(_a0 *models.WalletWithdrawal, _a1 error) *MockWalletService_Withdraw_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockWalletService_Withdraw_Call) RunAndReturn(run func(context.Context, models.WalletWithdrawalParams) (*models.WalletWithdrawal, error)) *MockWalletService_Withdraw_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWalletService creates a new instance of MockWalletService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWalletService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWalletService {
	mock := &MockWalletService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
